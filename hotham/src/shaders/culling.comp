#version 460

layout (local_size_x = 4) in;
struct VkDrawIndexedIndirectCommand
{
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
};

struct DrawData {
    mat4 transform;
    mat4 inverseTranspose;
    vec4 boundingSphere;
    uint materialID;
    uint skinID;
};

layout(std430, set = 0, binding = 0) readonly buffer DrawDataBuffer {
    DrawData data[];
} drawDataBuffer;

layout(std430, set = 0, binding = 1) writeonly buffer DrawCommandsBuffer {
    VkDrawIndexedIndirectCommand drawCommands[];
} drawCommandsBuffer;

layout(set = 0, binding = 2) uniform CullData {
    mat4 frustrum;
	uint drawCalls;
} cullData;

bool check_is_visible(mat4 mat, vec3 origin, float radius)
{
	uint plane_index = 0;
	for (uint i = 0; i < 3; ++i)
	{
		for (uint j = 0; j < 2; ++j, ++plane_index)
		{
			if (plane_index == 2 || plane_index == 3)
			{
				continue;
			}
			const float sign  = (j > 0) ? 1.f : -1.f;
			vec4        plane = vec4(0, 0, 0, 0);
			for (uint k = 0; k < 4; ++k)
			{
				plane[k] = mat[k][3] + sign * mat[k][i];
			}
			plane.xyzw /= sqrt(dot(plane.xyz, plane.xyz));
			if (dot(origin, plane.xyz) + plane.w + radius < 0)
			{
				return false;
			}
		}
	}

	return true;
}

void main() {
    uint id = gl_GlobalInvocationID.x;

	if (id >= cullData.drawCalls) { return; }

    DrawData d = drawDataBuffer.data[id];
    vec3 centre = d.boundingSphere.xyz;
    float radius = d.boundingSphere.w;

	// // Check each eye to see if the object is visible
    bool isVisible = check_is_visible(cullData.frustrum, centre, radius);
    drawCommandsBuffer.drawCommands[id].instanceCount = isVisible ? 1 : 0;
}