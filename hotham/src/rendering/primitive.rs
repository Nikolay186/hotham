use crate::{asset_importer::ImportContext, components::Transform, rendering::vertex::Vertex};
use itertools::izip;
use nalgebra::{vector, DimMax, Vector3, Vector4};

/// Geometry for a mesh
/// Automatically generated by `gltf_loader`
#[derive(Debug, Clone, PartialEq)]
pub struct Primitive {
    /// Offset into the index buffer
    pub index_buffer_offset: u32,
    /// Offset into vertex buffer
    pub vertex_buffer_offset: u32,
    /// Number of vertices
    pub indices_count: u32,
    /// Material used
    pub material_id: u32,
    /// Bounding sphere - used for culling
    pub bounding_sphere: Vector4<f32>,
}

impl Primitive {
    pub(crate) fn load(
        primitive_data: gltf::Primitive,
        import_context: &mut ImportContext,
        mesh_name: &str,
    ) -> Self {
        let mut indices = Vec::new();
        let mut positions = Vec::new();
        let mut tex_coords = Vec::new();
        let mut normals = Vec::new();
        let mut joint_indices = Vec::new();
        let mut joint_weights = Vec::new();

        let reader = primitive_data.reader(|_| Some(&import_context.buffer));

        // Positions
        for v in reader
            .read_positions()
            .expect(&format!("Mesh {} has no positions!", mesh_name))
        {
            positions.push(vector![v[0], v[1], v[2]]);
        }

        // Indices
        if let Some(iter) = reader.read_indices() {
            for i in iter.into_u32() {
                indices.push(i);
            }
        }

        // Normals
        if let Some(iter) = reader.read_normals() {
            for v in iter {
                normals.push(vector![v[0], v[1], v[2]]);
            }
        } else {
            for _ in 0..positions.len() {
                normals.push(vector![0., 0., 0.]);
            }
        }

        if let Some(iter) = reader.read_tex_coords(0) {
            for v in iter.into_f32() {
                tex_coords.push(vector![v[0], v[1]]);
            }
        } else {
            for _ in 0..positions.len() {
                tex_coords.push(vector![0., 0.]);
            }
        }

        if let Some(iter) = reader.read_joints(0) {
            for t in iter.into_u16() {
                joint_indices.push(vector![t[0] as f32, t[1] as f32, t[2] as f32, t[3] as f32]);
            }
        } else {
            for _ in 0..positions.len() {
                joint_indices.push(vector![0., 0., 0., 0.]);
            }
        }

        if let Some(iter) = reader.read_weights(0) {
            for t in iter.into_f32() {
                joint_weights.push(vector![t[0] as f32, t[1] as f32, t[2] as f32, t[3] as f32]);
            }
        } else {
            for _ in 0..positions.len() {
                joint_weights.push(vector![0., 0., 0., 0.]);
            }
        }
        let bounding_sphere = calculate_bounding_sphere(&positions);

        let vertices: Vec<Vertex> =
            izip!(positions, normals, tex_coords, joint_indices, joint_weights)
                .into_iter()
                .map(Vertex::from_zip)
                .collect();

        // Grab the offsets - note that we want to do this BEFORE we add these vertices to the buffer.
        let vertex_buffer = &mut import_context.render_context.resources.vertex_buffer;
        let index_buffer = &mut import_context.render_context.resources.index_buffer;
        let vertex_buffer_offset = vertex_buffer.len as _;
        let index_buffer_offset = index_buffer.len as _;

        // Update the buffers
        unsafe {
            vertex_buffer.append(&vertices);
            index_buffer.append(&indices);
        }

        // All the materials in this glTF file will be imported into the material buffer, so all we need
        // to do is grab the index of this material and add it to the running offset. If we don't do this,
        // importing multiple glTF files will result in sadness, misery, and really ugly looking scenes.
        let material_id = primitive_data
            .material()
            .index()
            .expect("Primitives without materials are not yet supported!")
            as u32
            + import_context.material_buffer_offset;

        Primitive {
            vertex_buffer_offset,
            index_buffer_offset,
            material_id,
            indices_count: indices.len() as _,
            bounding_sphere,
        }
    }

    /// Get a bounding sphere for the primitive, applying a transform
    pub fn get_bounding_sphere(&self, transform: &Transform) -> Vector4<f32> {
        let mut centre = self.bounding_sphere.xyz();
        let mut radius = self.bounding_sphere.w;

        centre += transform.translation;
        radius *= transform.scale.max();

        [centre.x, centre.y, centre.z, radius].into()
    }
}

/// Get a bounding sphere for the primitive, used for occlusion culling
pub fn calculate_bounding_sphere(points: &[Vector3<f32>]) -> Vector4<f32> {
    let mut centre = Vector3::zeros();
    if points.len() == 0 {
        return Default::default();
    }

    for p in points {
        centre += p;
    }

    centre /= points.len() as f32;
    let mut radius = (&points[0] - &centre).norm_squared();
    for p in points.iter().skip(1) {
        radius = radius.max((p - &centre).norm_squared());
    }

    radius = next_up(radius.sqrt());

    [centre.x, centre.y, centre.z, radius].into()
}

const TINY_BITS: u32 = 0x1; // Smallest positive f32.
const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;

fn next_up(n: f32) -> f32 {
    let bits = n.to_bits();
    if n.is_nan() || bits == f32::INFINITY.to_bits() {
        return n;
    }

    let abs = bits & CLEAR_SIGN_MASK;
    let next_bits = if abs == 0 {
        TINY_BITS
    } else if bits == abs {
        bits + 1
    } else {
        bits - 1
    };
    f32::from_bits(next_bits)
}
